#include "bits/stdc++.h"
using namespace std;
const int N = 510,M = 1e4 + 10;
int n,k,m;
struct Edge{
	int f;//from
	int t;//to
	int w;
}edges[M];
int dis[N],back[N],cnt;
//bellman_ford 适用于处理负权边，以及最多经过k条边的问题
void bellman_Ford()
{
	fill(dis,dis + N,1e9 + 10);
	dis[1] = 0;
	//最多经过k条边
	for(int i = 1;i <= k;i++){
		//防止出现串联情况，及连续更新，这样更新的次数不止看k次
		//1 2 1
		//2 3 2
		//3 4 1
		//1 3 -5
		memcpy(back,dis,sizeof(dis));
		for(int j = 1;j <= m;j++){
			dis[edges[j].t] = min(dis[edges[j].t],back[edges[j].f] + edges[j].w);
		}
	}
	//注意这里dis[n] > (1e9 + 10) / 2，是因为这里不像Dijkstra写等于正无穷是因为可能有负权边甚至是负环的存在，
    //使得“正无穷”在迭代过程中受到一点影响
	if(dis[n] > (1e9 + 10) / 2) cout<<"impossible"<<endl;
	else cout<< dis[n];
}
void add(int u,int v,int w)
{
	edges[++cnt].f = u;
	edges[cnt].t = v;
	edges[cnt].w = w;
}
int main()
{
	cin >> n >> m >> k;
	for(int i = 1;i <= m;i++){
		int u,v,w;
		cin >> u >> v >> w;
		add(u,v,w);
	}
	bellman_Ford();
	return 0;
}
